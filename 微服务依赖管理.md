近年来随着微服务的流行，越来越多的企业把微服务架构作为自己新建或重构系统的首选。微服务架构有它自己的适用范围，其实是一种成本很高的架构。当想要做这样的选择时，必须考虑清楚，希望通过微服务架构解决什么问题？我们具备怎样的能力？并非都可以通过将服务拆小和拆细，来把所有的问题简化。
以下几点都会对是否能顺畅切换的微服务的方式，产生重要的影响。
* 团队的组织模式
* DevOps的支持程度
* 项目的管理方式
* 人员的能力

本文并非要解决微服务的痛点，也并不打算展开介绍如何微服务转型。就微服务化过程中，碰到的依赖管理方面的问题展开一些讨论。

## 版本统一管理
本次咨询的项目是一个java的微服务项目，每个微服务发布一个独立jar包。对于纯正的微服务架构来说，各个服务应该是具备独立部署的能力的，但在该项目还是采用大项目组的方式，统一规划各组的开发测试阶段，所以需要统一部署。

为避免重复的打包过程和不同环境打包引入的风险，我们通常会使用制品库（本次使用nexus）来管理打包后的jar包，这样在各个环境上流动的是验证后的在制品，而不是每次通过源码进行重新的构建产物。

为了统一整个部署过程，设计了一个一致性的版本文件（serverList），该文件中包含全量的微服务版本情况。这样Jenkins的job只需要根据serverList中各个服务的版本号从制品库中获取，部署到指定环境即可。
serverList由各个开发组维护，不同的环境和版本的serverList应该有对应关系，serverList以纯文本的形式在gitlab中管理，以保证变更过程有迹可循。

## 外部依赖
在项目中我们通常使用dependecnyManagement来统一管理外部的版本依赖，所有微服务的jar包有个统一的parent-pom文件，在parent里可以管理外部依赖版本号，需要用到的微服务只需要定义我依赖哪些外部服务即可，可以不指定版本号，这样在被依赖的外部版本升级时，可以不需要频繁的调整各个服务的pom文件，只修改parent一个地方。

## 内部依赖
本次项目是使用rpc的交互方式，每个服务一般会分成2个pom一个facade的pom，一个service的pom，这2个pom的版本号应该是独立演进的，接口的pom应该相对稳定。服务之间的调用需要引入被调用方的facade版本，如果facade的版本在每个微服务的pom中管理，一旦被调用方的版本升级，有可能会需要每个调用服务都修改自己的pom文件。因此建议也使用dependecnyManagement来管理各个微服务的接口版本号，这样每个微服务在版本更新时，只需要修改2处即可（自己和parent）。

这样的便捷还是有一定的副作用，例如：parent里管理的某个facade版本号变化了，无法直观的知道哪些服务依赖了这个facade，最简单粗暴的做法就是所有的微服务只看到parent发生了变化，全部重新构建。要做到精细的触发，就需要通过扫描建立依赖关系的拓扑图了。

有人会说为什么不用RELEASE和LATEST来免除更新的问题？原因在于maven3后续将不再支持这样的特性，官方推荐使用version插件来进行必要的管理。

## 多分支下的依赖管理
当今项目，普遍的使用git来作为源码管理工具，得益于git的轻量分支，也衍生出各种的工作流或分支模型。对于采用maven等现代依赖管理工具的开发团队，不管采用的是何种分支模型，都将面临版本号管理的问题。
通常在开发阶段，pom中的版本号会采用SNAPSHOT的方式来管理，避免频繁提升版本号带来的额外成本。那什么时候把SNAPSHOT版本号升级为release的版本号？又如何管理在各个分支上版本号的演进？想必是大家都会碰到的问题。以下是我们在真实咨询项目中的通过多伦迭代的版本号管理策略，兴许对其他同路人有借鉴的意义。
先抛出问题和痛点：
* 在不同分支上版本号是否会相互影响
* 版本号何时变成release，release版本号递增引起的相关改动工作量。
* 如何和serverList结合使用

## 分支模型
首先需要介绍下采用的分支模型，本项目主要采用主干开发的方式



