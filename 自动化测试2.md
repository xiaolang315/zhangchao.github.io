自动化测试作为敏捷技术实践的一环，被广泛应用，和持续集成一起发挥着防护网的作用。从事系统软件开发的我们，为什么开始觉得测试越来越难写，越来越难维护，最终反而成为负担？ 系统软件的一大特征是整个产品生命周期长，对应的测试代码的生命周期也将长达数年。在关注业务代码腐坏的同时，我们也要警惕测试，我们不能通过测试从业务代码的泥潭里走出来，又掉入了测试混乱的泥潭中。

## 测试用例的维护
随着测试用例作为交付的必要输出，用例的质量也在规模化的情况下，凸显出来。用例的运行效率，编写效率，都不可避免的成为研发效率提升的重要环节。
***
# 测试用例

## 测试用例设计
### 测试用例名
首先测试用例的名字和内容要表达相同，修改测试内容的时候一定要保持用例名字的随同变更，最好能完整体现条件，过程及结果。
> 反例1： test1，test2，
> 反例2： add_test，cell_test，
> 正例 ： should_report_xx_kpi_when_msg5_timeout_in_attch

### 单一职责
每个用例只测试一个需求或故障点，如何发现测试不单一的坏味道
* 从用例名可以看出，例如名字中出现类似并列的期望结果或条件；名字过于概况
> 反例： should_erab_1_setup_fail_and_erab2_setup_succ_after_attach
* 从预先设置项可以看出，多个测试点公用一个用例会导致一些前置条件变多，变复杂。
* 从测试步骤观察，前面的步骤并不是作为后面的步骤前提。
* 过多的ASSERT，说明可能关注点不聚焦，职责不单一

### 测试表达
#### 哪些用例应该放在同一个测试套件内? 
具有相同场景或前提，并非作为一个套间的必要前提，测试用例间的重复的消除，合成一个测试套件不是唯一选择，提取公共流程函数或基类都是可选择的方法。测试同一个功能点的不同方面，适合放在一起。

#### 测试套内什么东西该往setup和teardown里放？
可以从套间内的用例名或内容中发现变化的点，也就是你的测试重点，应该在用例主体中体现的内容。重点内容之前，且所有用例都公用的流程，就应该放setup里，同理重点内容之后的teardown，穿插于重点参数变化和校验变化的其他辅助的流程，则非常有必要封装起来，达到重点突出的效果。

#### BDD风格
参考BDD风格的描述用例内容, given when then 虽然不是必须遵守的形式，但可以帮助你理清内容的选择。
>   TEST("one ue attach succ to cell 2!")
>	{
>        given_ue_cfg(toCell(2));
>        when_ue_do(attach(); detach(););
>        then_should_check(
>                  given_rnlu_check({ASSERT_TRUE(req.wCellId == 2);})
>        );
>	}

### 测试用例正交设计
所谓正交，就是两个用例并不重复的验证同一个测试点。
>   TEST(" foo should be idle state when init!")
>	{
>	    Foo foo;
>       ASSERT_TEUE(foo.isIdle());
>	}
>   TEST("foo should trun to work after touch")
>	{
>	    Foo foo;
>       //ASSERT_TEUE(foo.isIdle()); should not check in this case
>       foo.touch();
>       ASSERT_TEUE(foo.isWorking());
>        );
>	}

但这里经常有个误区，之前的测试过的基本流程在后续的测试中会作为基本步骤的情况，并不算非正交的用例设计。

### 语法糖
适度的语法糖是可以大大提升用例的表现能力。
> \#define _erab_id_(id) id
> \#define _qci_(value) value
> \#define _rb_id_(value) value
> \#define _uerb_id_(value) value
> const EutranErab defaultAmErab(_erab_id_(5), _qci_(8), RB_RLC_MODE_AM, _uerb_id_(1))

### 测试封装(消除重复)
测试用例也要像正式代码一样，是需要长期维护的，非必要的重复必须消除掉，否则将来用例规模大后，我们的些许改动将面临着巨大的工作量。但绝对不要出现单纯的为了封装而封装，否则同样面临着将来维护困难的局面。

### 测试范围
首先确定我们要写的用例的测试分层位置，Ft要关注到什么是我们的边界，我们是否要依赖我们内部的消息号或者结构输入，来作为激励源？Ut要尽量缩小测试的范围，被测函数或类型一定要控制在有效的稳定范围内，否则通篇的UT面临重构时也是噩梦。

### 外部系统
如果有和外部系统打交道的，可以建立模拟对象，与对应系统的交互必须通过该模拟对象进行，并将逻辑注入模拟对象，以此校验我们对外围的影响和逻辑是否合理。例如：外部系统必须先配置A才可以接收B，该状态就可以记录在模拟对象上，如果模拟对象A后面收到了非B的配置即可抛出异常。

针对外部系统的模拟中，如果接口是函数调用的形式，我们将面临有2种解决方法，stub和mock
* stub是将调用的外部接口实现，通过实现将接口内容导入到我们可以验证的内容上，加以验证。由于自己实现也可以控制输出。
* mock的方式是使用工具来完成，不实现该函数，注入对接口的期望和模拟，完成校验和交互设计。

### 注意事项
完成代码后再补充测试用例的一个很容易犯的错误就是，照着当前的运行结果或代码来补充用例，此举无异于饮鸩止渴。
